# @software: PyCharm

# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange

# -----------------------------------------------------------------------------

try:
    basestring  # Python 3
except NameError:
    basestring = str  # Python 2
import hashlib
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import AccountSuspended
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidAddress
from ccxt.base.errors import InvalidOrder
from ccxt.base.errors import OrderNotFound
from ccxt.base.errors import CancelPending
from ccxt.base.errors import NotSupported
from ccxt.base.errors import DDoSProtection
from ccxt.base.errors import RateLimitExceeded
from ccxt.base.errors import ExchangeNotAvailable
from ccxt.base.errors import OnMaintenance
from ccxt.base.errors import InvalidNonce
from ccxt.base.errors import RequestTimeout, AuthenticationError
from ccxt.base.decimal_to_precision import TRUNCATE
from ccxt.base.decimal_to_precision import TICK_SIZE


# from ccxt.base.precise import Precise


class okex(Exchange):
    def describe(self):
        return self.deep_extend(super(okex, self).describe(), {
            'id': 'okex',
            'name': 'OKEX',
            'countries': ['CN', 'US'],
            'version': 'v5',
            'rateLimit': 1000,
            # up to 3000 requests per 5 minutes ≈ 600 requests per minute ≈ 10 requests per second ≈ 100 ms
            'pro': True,
            'has': {
                'cancelOrder': True,
                'CORS': False,
                'createOrder': True,
                'fetchBalance': True,
                'fetchClosedOrders': True,
                'fetchCurrencies': False,  # see below
                'fetchDepositAddress': True,
                'fetchDeposits': True,
                'fetchLedger': True,
                'fetchMarkets': True,
                'fetchMyTrades': True,
                'fetchOHLCV': True,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchOrders': False,
                'fetchOrderTrades': True,
                'fetchTime': True,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTrades': True,
                'fetchTransactions': False,
                'fetchWithdrawals': True,
                'futures': True,
                'withdraw': True,
            },
            'timeframes': {
                '1m': '60',
                '3m': '180',
                '5m': '300',
                '15m': '900',
                '30m': '1800',
                '1h': '3600',
                '2h': '7200',
                '4h': '14400',
                '6h': '21600',
                '12h': '43200',
                '1d': '86400',
                '1w': '604800',
                '1M': '2678400',
                '3M': '8035200',
                '6M': '16070400',
                '1y': '31536000',
            },
            'hostname': 'okex.com',
            'urls': {
                'logo': 'https://user-images.githubusercontent.com/1294454/32552768-0d6dd3c6-c4a6-11e7-90f8-c043b64756a7.jpg',
                'api': {
                    'rest': 'https://www.{hostname}',
                },
                'www': 'https://www.okex.com',
                'doc': 'https://www.okex.com/docs/en/',
                'fees': 'https://www.okex.com/pages/products/fees.html',
                'referral': 'https://www.okex.com/join/1888677',
                'test': {
                    'rest': 'https://testnet.okex.com',
                },
            },
            'api': {
                'public': {
                    'get': [
                        'instruments',
                    ]
                },
                'market': {
                    'get': [
                        'books',
                    ]
                },
                'general': {
                    'get': [
                        'time',
                    ],
                },
                'account': {
                    'get': [
                        'balance',
                        'trade-fee',
                    ]
                },
                'trade': {
                    'get': [
                        'fills',
                        'order',  # 获取订单信息
                        'orders-pending',  # 获取历史订单记录（近三个月）
                        'orders-history-archive',  # 获取历史订单记录（近三个月）
                    ],
                    'post': [
                        'order',
                        'cancel-order',  # 撤单
                    ]
                }
            },
            'fees': {
                'trading': {
                    'taker': 0.0015,
                    'maker': 0.0010,
                },
                'spot': {
                    'taker': 0.0015,
                    'maker': 0.0010,
                },
                'futures': {
                    'taker': 0.0005,
                    'maker': 0.0002,
                },
                'swap': {
                    'taker': 0.00075,
                    'maker': 0.00020,
                },
            },
            'requiredCredentials': {
                'apiKey': True,
                'secret': True,
                'password': True,
            },
            'exceptions': {
                # http error codes
                # 400 Bad Request — Invalid request format
                # 401 Unauthorized — Invalid API Key
                # 403 Forbidden — You do not have access to the requested resource
                # 404 Not Found
                # 429 Client Error: Too Many Requests for url
                # 500 Internal Server Error — We had a problem with our server
                'code': {
                    '50105': AuthenticationError, # {"msg":"Request header “OK_ACCESS_PASSPHRASE“ incorrect.","code":"50105"}
                    '50111': AuthenticationError,  # {"msg":"Invalid OK-ACCESS-KEY","code":"50111"}
                    '50113': AuthenticationError,  # {"msg":"Invalid Sign","code":"50113"}
                    '51000': InvalidOrder,  # {"code":"51000","data":[],"msg":"Parameter clOrdId  error"}
                    '51001': BadSymbol,  # {"code":"51001","data":[],"msg":"Instrument ID does not exist."}
                    '51002': BadSymbol,
                    '51004': InvalidOrder,
                    '51005': InvalidOrder,
                    '51006': InvalidOrder,
                    '51007': InvalidOrder,
                    '51008': InsufficientFunds,
                    '51011': InvalidOrder,
                    '51012': BadSymbol,  # {"code":"51012","msg":"Token does not exist.","data":[]}
                    '51015': BadSymbol,
                    '51016': InvalidOrder,
                    '51020': InvalidOrder,
                    '51025': InvalidOrder,
                    '51101': InvalidOrder,
                    '51102': InvalidOrder,
                    '51103': InvalidOrder,
                    '51104': InvalidOrder,
                    '51105': InvalidOrder,
                    '51106': InvalidOrder,
                    '51107': InvalidOrder,
                    '51119': InvalidOrder,
                    '51120': InvalidOrder,
                    '51127': InsufficientFunds,
                    '51131': InsufficientFunds,
                    '51201': InvalidOrder,
                    '51202': InvalidOrder,
                    '51203': InvalidOrder,
                    '51204': InvalidOrder,
                    '51400': OrderNotFound,
                    '51401': OrderNotFound,
                    '51406': InvalidOrder,
                    # {"code":"1","data":[{"clOrdId":"","ordId":"304347285861842944","sCode":"51401","sMsg":"Cancellation failed as the order is already cancelled."}],"msg":""}
                    '51402': OrderNotFound,
                    '51403': OrderNotFound,
                    '51410': OrderNotFound,
                    '51503': OrderNotFound,
                    '51603': OrderNotFound,
                }
            },
            'precisionMode': TICK_SIZE,
            'options': {
                'fetchOHLCV': {
                    'type': 'Candles',  # Candles or HistoryCandles
                },
                'createMarketBuyOrderRequiresPrice': True,
                'fetchMarkets': ['spot', 'futures', 'swap', 'option'],
                'defaultType': 'spot',  # 'account', 'spot', 'margin', 'futures', 'swap', 'option'
                'auth': {
                    'time': 'public',
                    'currencies': 'private',
                    'instruments': 'public',
                    'rate': 'public',
                    '{instrument_id}/constituents': 'public',
                },
            },
            'commonCurrencies': {
                # OKEX refers to ERC20 version of Aeternity(AEToken)
                'AE': 'AET',  # https://github.com/ccxt/ccxt/issues/4981
                'BOX': 'DefiBox',
                'HOT': 'Hydro Protocol',
                'HSR': 'HC',
                'MAG': 'Maggie',
                'SBTC': 'Super Bitcoin',
                'YOYO': 'YOYOW',
                'WIN': 'WinToken',  # https://github.com/ccxt/ccxt/issues/5701
            },
        })

    async def fetch_time(self, params={}):
        response = await self.generalGetTime(params)
        #
        #     {
        #         "iso": "2015-01-07T23:47:25.201Z",
        #         "epoch": 1420674445.201
        #     }
        #
        return self.parse8601(self.safe_string(response, 'iso'))

    async def fetch_markets(self, params={}):
        method = 'publicGetInstruments'
        response = await getattr(self, method)(params)
        return self.parse_markets(response['data'])

    def parse_markets(self, markets):
        result = []
        for i in range(0, len(markets)):
            result.append(self.parse_market(markets[i]))
        return result

    def parse_market(self, market):
        #
        # {
        #     "code": "0",
        #     "msg": "",
        #     "data": [
        #         {
        #             "instType": "SWAP",
        #             "instId": "LTC-USD-SWAP",
        #             "uly": "LTC-USD",
        #             "category": "1",
        #             "baseCcy": "",
        #             "quoteCcy": "",
        #             "settleCcy": "LTC",
        #             "ctVal": "10",
        #             "ctMult": "1",
        #             "ctValCcy": "USD",
        #             "optType": "C",
        #             "stk": "",
        #             "listTime": "1597026383085",
        #             "expTime": "1597026383085",
        #             "lever": "10",
        #             "tickSz": "0.01",
        #             "lotSz": "1",
        #             "minSz": "1",
        #             "ctType": "linear",
        #             "alias": "this_week",
        #             "state": "live"
        #         }
        #     ]
        # }
        #

        marketType = 'spot'
        spot = True
        future = False
        swap = False
        option = False
        baseId = self.safe_string(market, 'baseCcy')
        quoteId = self.safe_string(market, 'quoteCcy')
        id = baseId + '-' + quoteId
        base = self.safe_currency_code(baseId)
        quote = self.safe_currency_code(quoteId)
        symbol = (base + '/' + quote) if spot else id
        precision = {
            'amount': self.precision_from_string(self.safe_string(market, 'lotSz')),
            'price': self.precision_from_string(self.safe_string(market, 'tickSz')),
        }
        minAmount = self.safe_number(market, 'minSz')
        active = True
        fees = self.safe_value_2(self.fees, marketType, 'trading', {})
        return self.extend(fees, {
            'id': id,
            'symbol': symbol,
            'base': base,
            'quote': quote,
            'baseId': baseId,
            'quoteId': quoteId,
            'info': market,
            'type': marketType,
            'spot': spot,
            'futures': future,
            'swap': swap,
            'option': option,
            'active': active,
            'precision': precision,
            'limits': {
                'amount': {
                    'min': minAmount,
                    'max': None,
                },
                'price': {
                    'min': precision['price'],
                    'max': None,
                },
                'cost': {
                    'min': precision['price'],
                    'max': None,
                },
            },
        })

    async def fetch_markets_by_type(self, type, params={}):
        if type == 'option':
            underlying = await self.optionGetUnderlying(params)
            result = []
            for i in range(0, len(underlying)):
                response = await self.optionGetInstrumentsUnderlying({
                    'underlying': underlying[i],
                })
                #
                # options markets
                #
                #     [
                #         {
                #             instrument_id: 'BTC-USD-200327-4000-C',
                #             underlying: 'BTC-USD',
                #             settlement_currency: 'BTC',
                #             contract_val: '0.1000',
                #             option_type: 'C',
                #             strike: '4000',
                #             tick_size: '0.0005',
                #             lot_size: '1.0000',
                #             listing: '2019-12-25T08:30:36.302Z',
                #             delivery: '2020-03-27T08:00:00.000Z',
                #             state: '2',
                #             trading_start_time: '2019-12-25T08:30:36.302Z',
                #             timestamp: '2020-03-13T08:05:09.456Z',
                #         },
                #     ]
                #
                result = self.array_concat(result, response)
            return self.parse_markets(result)
        elif (type == 'spot') or (type == 'futures') or (type == 'swap'):
            method = type + 'GetInstruments'
            response = await getattr(self, method)(params)
            #
            # spot markets
            #
            #     [
            #         {
            #             base_currency: "EOS",
            #             instrument_id: "EOS-OKB",
            #             min_size: "0.01",
            #             quote_currency: "OKB",
            #             size_increment: "0.000001",
            #             tick_size: "0.0001"
            #         }
            #     ]
            #
            # futures markets
            #
            #     [
            #         {
            #             instrument_id: "XRP-USD-200320",
            #             underlying_index: "XRP",
            #             quote_currency: "USD",
            #             tick_size: "0.0001",
            #             contract_val: "10",
            #             listing: "2020-03-06",
            #             delivery: "2020-03-20",
            #             trade_increment: "1",
            #             alias: "self_week",
            #             underlying: "XRP-USD",
            #             base_currency: "XRP",
            #             settlement_currency: "XRP",
            #             is_inverse: "true",
            #             contract_val_currency: "USD",
            #         }
            #     ]
            #
            # swap markets
            #
            #     [
            #         {
            #             instrument_id: "BSV-USD-SWAP",
            #             underlying_index: "BSV",
            #             quote_currency: "USD",
            #             coin: "BSV",
            #             contract_val: "10",
            #             listing: "2018-12-21T07:53:47.000Z",
            #             delivery: "2020-03-14T08:00:00.000Z",
            #             size_increment: "1",
            #             tick_size: "0.01",
            #             base_currency: "BSV",
            #             underlying: "BSV-USD",
            #             settlement_currency: "BSV",
            #             is_inverse: "true",
            #             contract_val_currency: "USD"
            #         }
            #     ]
            #
            return self.parse_markets(response)
        else:
            raise NotSupported(self.id + ' fetchMarketsByType does not support market type ' + type)

    async def fetch_currencies(self, params={}):
        # has['fetchCurrencies'] is currently set to False
        # despite that their docs say these endpoints are public:
        #     https://www.okex.com/api/account/v3/withdrawal/fee
        #     https://www.okex.com/api/account/v3/currencies
        # it will still reply with {"code":30001, "message": "OK-ACCESS-KEY header is required"}
        # if you attempt to access it without authentication
        response = await self.accountGetCurrencies(params)
        #
        #     [
        #         {
        #             name: '',
        #             currency: 'BTC',
        #             can_withdraw: '1',
        #             can_deposit: '1',
        #             min_withdrawal: '0.0100000000000000'
        #         },
        #     ]
        #
        result = {}
        for i in range(0, len(response)):
            currency = response[i]
            id = self.safe_string(currency, 'currency')
            code = self.safe_currency_code(id)
            precision = 0.00000001  # default precision, todo: fix "magic constants"
            name = self.safe_string(currency, 'name')
            canDeposit = self.safe_integer(currency, 'can_deposit')
            canWithdraw = self.safe_integer(currency, 'can_withdraw')
            active = True if (canDeposit and canWithdraw) else False
            result[code] = {
                'id': id,
                'code': code,
                'info': currency,
                'type': None,
                'name': name,
                'active': active,
                'fee': None,  # todo: redesign
                'precision': precision,
                'limits': {
                    'amount': {'min': None, 'max': None},
                    'price': {'min': None, 'max': None},
                    'cost': {'min': None, 'max': None},
                    'withdraw': {
                        'min': self.safe_number(currency, 'min_withdrawal'),
                        'max': None,
                    },
                },
            }
        return result

    async def fetch_order_book(self, symbol, limit=None, params={}):
        await self.load_markets()
        # market = self.market(symbol)
        # method = market['type'] + 'GetInstrumentsInstrumentId'
        # method += 'Depth' if (market['type'] == 'swap') else 'Book'
        method = 'marketGetBooks'
        request = {
            'instId': symbol,
        }
        if limit is not None:
            request['sz'] = limit  # max 200
        response = await getattr(self, method)(self.extend(request, params))
        #
        #     {     asks: [["0.02685268", "0.242571", "1"],
        #                    ["0.02685493", "0.164085", "1"],
        #                    ...
        #                    ["0.02779", "1.039", "1"],
        #                    ["0.027813", "0.0876", "1"]        ],
        #            bids: [["0.02684052", "10.371849", "1"],
        #                    ["0.02684051", "3.707", "4"],
        #                    ...
        #                    ["0.02634963", "0.132934", "1"],
        #                    ["0.02634962", "0.264838", "2"]    ],
        #       timestamp:   "2018-12-17T20:24:16.159Z"            }
        #
        timestamp = self.parse8601(self.safe_string(response, 'timestamp'))
        return self.parse_order_book(response['data'][0], timestamp)

    def parse_ticker(self, ticker, market=None):
        #
        #     {        best_ask: "0.02665472",
        #               best_bid: "0.02665221",
        #          instrument_id: "ETH-BTC",
        #             product_id: "ETH-BTC",
        #                   last: "0.02665472",
        #                    ask: "0.02665472",  # missing in the docs
        #                    bid: "0.02665221",  # not mentioned in the docs
        #               open_24h: "0.02645482",
        #               high_24h: "0.02714633",
        #                low_24h: "0.02614109",
        #        base_volume_24h: "572298.901923",
        #              timestamp: "2018-12-17T21:20:07.856Z",
        #       quote_volume_24h: "15094.86831261"            }
        #
        timestamp = self.parse8601(self.safe_string(ticker, 'timestamp'))
        symbol = None
        marketId = self.safe_string(ticker, 'instrument_id')
        if marketId in self.markets_by_id:
            market = self.markets_by_id[marketId]
            symbol = market['symbol']
        elif marketId is not None:
            parts = marketId.split('-')
            numParts = len(parts)
            if numParts == 2:
                baseId, quoteId = parts
                base = self.safe_currency_code(baseId)
                quote = self.safe_currency_code(quoteId)
                symbol = base + '/' + quote
            else:
                symbol = marketId
        if (symbol is None) and (market is not None):
            symbol = market['symbol']
        last = self.safe_number(ticker, 'last')
        open = self.safe_number(ticker, 'open_24h')
        return {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_number(ticker, 'high_24h'),
            'low': self.safe_number(ticker, 'low_24h'),
            'bid': self.safe_number(ticker, 'best_bid'),
            'bidVolume': self.safe_number(ticker, 'best_bid_size'),
            'ask': self.safe_number(ticker, 'best_ask'),
            'askVolume': self.safe_number(ticker, 'best_ask_size'),
            'vwap': None,
            'open': open,
            'close': last,
            'last': last,
            'previousClose': None,
            'change': None,
            'percentage': None,
            'average': None,
            'baseVolume': self.safe_number(ticker, 'base_volume_24h'),
            'quoteVolume': self.safe_number(ticker, 'quote_volume_24h'),
            'info': ticker,
        }

    async def fetch_ticker(self, symbol, params={}):
        await self.load_markets()
        market = self.market(symbol)
        method = market['type'] + 'GetInstrumentsInstrumentIdTicker'
        request = {
            'instrument_id': market['id'],
        }
        response = await getattr(self, method)(self.extend(request, params))
        #
        #     {        best_ask: "0.02665472",
        #               best_bid: "0.02665221",
        #          instrument_id: "ETH-BTC",
        #             product_id: "ETH-BTC",
        #                   last: "0.02665472",
        #                    ask: "0.02665472",
        #                    bid: "0.02665221",
        #               open_24h: "0.02645482",
        #               high_24h: "0.02714633",
        #                low_24h: "0.02614109",
        #        base_volume_24h: "572298.901923",
        #              timestamp: "2018-12-17T21:20:07.856Z",
        #       quote_volume_24h: "15094.86831261"            }
        #
        return self.parse_ticker(response)

    async def fetch_tickers_by_type(self, type, symbols=None, params={}):
        await self.load_markets()
        method = type + 'GetInstrumentsTicker'
        response = await getattr(self, method)(params)
        result = {}
        for i in range(0, len(response)):
            ticker = self.parse_ticker(response[i])
            symbol = ticker['symbol']
            result[symbol] = ticker
        return self.filter_by_array(result, 'symbol', symbols)

    async def fetch_tickers(self, symbols=None, params={}):
        defaultType = self.safe_string_2(self.options, 'fetchTickers', 'defaultType')
        type = self.safe_string(params, 'type', defaultType)
        return await self.fetch_tickers_by_type(type, symbols, self.omit(params, 'type'))

    def parse_trade(self, trade, market=None):
        #
        # fetchTrades(public)
        #
        #     spot trades
        #
        #         {
        #             time: "2018-12-17T23:31:08.268Z",
        #             timestamp: "2018-12-17T23:31:08.268Z",
        #             trade_id: "409687906",
        #             price: "0.02677805",
        #             size: "0.923467",
        #             side: "sell"
        #         }
        #
        #     futures trades, swap trades
        #
        #         {
        #             trade_id: "1989230840021013",
        #             side: "buy",
        #             price: "92.42",
        #             qty: "184",  # missing in swap markets
        #             size: "5",  # missing in futures markets
        #             timestamp: "2018-12-17T23:26:04.613Z"
        #         }
        #
        # fetchOrderTrades(private)
        #
        #     spot trades, margin trades
        #
        #         {
        #             "created_at":"2019-03-15T02:52:56.000Z",
        #             "exec_type":"T",  # whether the order is taker or maker
        #             "fee":"0.00000082",
        #             "instrument_id":"BTC-USDT",
        #             "ledger_id":"3963052721",
        #             "liquidity":"T",  # whether the order is taker or maker
        #             "order_id":"2482659399697408",
        #             "price":"3888.6",
        #             "product_id":"BTC-USDT",
        #             "side":"buy",
        #             "size":"0.00055306",
        #             "timestamp":"2019-03-15T02:52:56.000Z"
        #         },
        #
        #     futures trades, swap trades
        #
        #         {
        #             "trade_id":"197429674631450625",
        #             "instrument_id":"EOS-USD-SWAP",
        #             "order_id":"6a-7-54d663a28-0",
        #             "price":"3.633",
        #             "order_qty":"1.0000",
        #             "fee":"-0.000551",
        #             "created_at":"2019-03-21T04:41:58.0Z",  # missing in swap trades
        #             "timestamp":"2019-03-25T05:56:31.287Z",  # missing in futures trades
        #             "exec_type":"M",  # whether the order is taker or maker
        #             "side":"short",  # "buy" in futures trades
        #         }
        #
        symbol = None
        marketId = self.safe_string(trade, 'instrument_id')
        base = None
        quote = None
        if marketId in self.markets_by_id:
            market = self.markets_by_id[marketId]
            symbol = market['symbol']
            base = market['base']
            quote = market['quote']
        elif marketId is not None:
            parts = marketId.split('-')
            numParts = len(parts)
            if numParts == 2:
                baseId, quoteId = parts
                base = self.safe_currency_code(baseId)
                quote = self.safe_currency_code(quoteId)
                symbol = base + '/' + quote
            else:
                symbol = marketId
        if (symbol is None) and (market is not None):
            symbol = market['symbol']
            base = market['base']
            quote = market['quote']
        timestamp = self.parse8601(self.safe_string_2(trade, 'timestamp', 'created_at'))
        priceString = self.safe_string(trade, 'price')
        amountString = self.safe_string_2(trade, 'size', 'qty')
        amountString = self.safe_string(trade, 'order_qty', amountString)
        price = self.parse_number(priceString)
        amount = self.parse_number(amountString)
        # cost = self.parse_number(Precise.string_mul(priceString, amountString))
        cost = 0.
        takerOrMaker = self.safe_string_2(trade, 'exec_type', 'liquidity')
        if takerOrMaker == 'M':
            takerOrMaker = 'maker'
        elif takerOrMaker == 'T':
            takerOrMaker = 'taker'
        side = self.safe_string(trade, 'side')
        feeCost = self.safe_number(trade, 'fee')
        fee = None
        if feeCost is not None:
            feeCurrency = base if (side == 'buy') else quote
            fee = {
                # fee is either a positive number(invitation rebate)
                # or a negative number(transaction fee deduction)
                # therefore we need to invert the fee
                # more about it https://github.com/ccxt/ccxt/issues/5909
                'cost': -feeCost,
                'currency': feeCurrency,
            }
        orderId = self.safe_string(trade, 'order_id')
        return {
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'id': self.safe_string_2(trade, 'trade_id', 'ledger_id'),
            'order': orderId,
            'type': None,
            'takerOrMaker': takerOrMaker,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': fee,
        }

    async def fetch_trades(self, symbol, since=None, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        method = market['type'] + 'GetInstrumentsInstrumentIdTrades'
        if (limit is None) or (limit > 100):
            limit = 100  # maximum = default = 100
        request = {
            'instrument_id': market['id'],
            'limit': limit,
            # from: 'id',
            # to: 'id',
        }
        response = await getattr(self, method)(self.extend(request, params))
        #
        # spot markets
        #
        #     [
        #         {
        #             time: "2018-12-17T23:31:08.268Z",
        #             timestamp: "2018-12-17T23:31:08.268Z",
        #             trade_id: "409687906",
        #             price: "0.02677805",
        #             size: "0.923467",
        #             side: "sell"
        #         }
        #     ]
        #
        # futures markets, swap markets
        #
        #     [
        #         {
        #             trade_id: "1989230840021013",
        #             side: "buy",
        #             price: "92.42",
        #             qty: "184",  # missing in swap markets
        #             size: "5",  # missing in futures markets
        #             timestamp: "2018-12-17T23:26:04.613Z"
        #         }
        #     ]
        #
        return self.parse_trades(response, market, since, limit)

    def parse_ohlcv(self, ohlcv, market=None):
        #
        # spot markets
        #
        #     {
        #         close: "0.02684545",
        #         high: "0.02685084",
        #         low: "0.02683312",
        #         open: "0.02683894",
        #         time: "2018-12-17T20:28:00.000Z",
        #         volume: "101.457222"
        #     }
        #
        # futures markets
        #
        #     [
        #         1545072720000,
        #         0.3159,
        #         0.3161,
        #         0.3144,
        #         0.3149,
        #         22886,
        #         725179.26172331,
        #     ]
        #
        if isinstance(ohlcv, list):
            numElements = len(ohlcv)
            volumeIndex = 6 if (numElements > 6) else 5
            timestamp = self.safe_value(ohlcv, 0)
            if isinstance(timestamp, basestring):
                timestamp = self.parse8601(timestamp)
            return [
                timestamp,  # timestamp
                self.safe_number(ohlcv, 1),  # Open
                self.safe_number(ohlcv, 2),  # High
                self.safe_number(ohlcv, 3),  # Low
                self.safe_number(ohlcv, 4),  # Close
                # self.safe_number(ohlcv, 5),         # Quote Volume
                # self.safe_number(ohlcv, 6),         # Base Volume
                self.safe_number(ohlcv, volumeIndex),
                # Volume, okex will return base volume in the 7th element for future markets
            ]
        else:
            return [
                self.parse8601(self.safe_string(ohlcv, 'time')),
                self.safe_number(ohlcv, 'open'),  # Open
                self.safe_number(ohlcv, 'high'),  # High
                self.safe_number(ohlcv, 'low'),  # Low
                self.safe_number(ohlcv, 'close'),  # Close
                self.safe_number(ohlcv, 'volume'),  # Base Volume
            ]

    async def fetch_ohlcv(self, symbol, timeframe='1m', since=None, limit=None, params={}):
        await self.load_markets()
        market = self.market(symbol)
        duration = self.parse_timeframe(timeframe)
        request = {
            'instrument_id': market['id'],
            'granularity': self.timeframes[timeframe],
        }
        options = self.safe_value(self.options, 'fetchOHLCV', {})
        defaultType = self.safe_string(options, 'type', 'Candles')  # Candles or HistoryCandles
        type = self.safe_string(params, 'type', defaultType)
        params = self.omit(params, 'type')
        method = market['type'] + 'GetInstrumentsInstrumentId' + type
        if type == 'Candles':
            if since is not None:
                if limit is not None:
                    request['end'] = self.iso8601(self.sum(since, limit * duration * 1000))
                request['start'] = self.iso8601(since)
            else:
                if limit is not None:
                    now = self.milliseconds()
                    request['start'] = self.iso8601(now - limit * duration * 1000)
                    request['end'] = self.iso8601(now)
        elif type == 'HistoryCandles':
            if market['option']:
                raise NotSupported(
                    self.id + ' fetchOHLCV does not have ' + type + ' for ' + market['type'] + ' markets')
            if since is not None:
                if limit is None:
                    limit = 300  # default
                request['start'] = self.iso8601(self.sum(since, limit * duration * 1000))
                request['end'] = self.iso8601(since)
            else:
                if limit is not None:
                    now = self.milliseconds()
                    request['end'] = self.iso8601(now - limit * duration * 1000)
                    request['start'] = self.iso8601(now)
        response = await getattr(self, method)(self.extend(request, params))
        #
        # spot markets
        #
        #     [
        #         {
        #             close: "0.02683401",
        #             high: "0.02683401",
        #             low: "0.02683401",
        #             open: "0.02683401",
        #             time: "2018-12-17T23:47:00.000Z",
        #             volume: "0"
        #         },
        #         {
        #             close: "0.02684545",
        #             high: "0.02685084",
        #             low: "0.02683312",
        #             open: "0.02683894",
        #             time: "2018-12-17T20:28:00.000Z",
        #             volume: "101.457222"
        #         }
        #     ]
        #
        # futures
        #
        #     [
        #         [
        #             1545090660000,
        #             0.3171,
        #             0.3174,
        #             0.3171,
        #             0.3173,
        #             1648,
        #             51930.38579450868
        #         ],
        #         [
        #             1545072720000,
        #             0.3159,
        #             0.3161,
        #             0.3144,
        #             0.3149,
        #             22886,
        #             725179.26172331
        #         ]
        #     ]
        #
        return self.parse_ohlcvs(response, market, timeframe, since, limit)

    def parse_account_balance(self, response):
        #
        # account
        #
        #     [
        #         {
        #             balance:  0,
        #             available:  0,
        #             currency: "BTC",
        #             hold:  0
        #         },
        #         {
        #             balance:  0,
        #             available:  0,
        #             currency: "ETH",
        #             hold:  0
        #         }
        #     ]
        #
        # spot
        #
        #     [
        #         {
        #             frozen: "0",
        #             hold: "0",
        #             id: "2149632",
        #             currency: "BTC",
        #             balance: "0.0000000497717339",
        #             available: "0.0000000497717339",
        #             holds: "0"
        #         },
        #         {
        #             frozen: "0",
        #             hold: "0",
        #             id: "2149632",
        #             currency: "ICN",
        #             balance: "0.00000000925",
        #             available: "0.00000000925",
        #             holds: "0"
        #         }
        #     ]
        #
        result = {'info': response}
        for i in range(0, len(response)):
            balance = response[i]
            currencyId = self.safe_string(balance, 'currency')
            code = self.safe_currency_code(currencyId)
            account = self.account()
            account['total'] = self.safe_number(balance, 'balance')
            account['used'] = self.safe_number(balance, 'hold')
            account['free'] = self.safe_number(balance, 'available')
            result[code] = account
        return self.parse_balance(result)

    def parse_margin_balance(self, response):
        #
        #     [
        #         {
        #             "currency:BTC": {
        #                 "available":"0",
        #                 "balance":"0",
        #                 "borrowed":"0",
        #                 "can_withdraw":"0",
        #                 "frozen":"0",
        #                 "hold":"0",
        #                 "holds":"0",
        #                 "lending_fee":"0"
        #             },
        #             "currency:USDT": {
        #                 "available":"100",
        #                 "balance":"100",
        #                 "borrowed":"0",
        #                 "can_withdraw":"100",
        #                 "frozen":"0",
        #                 "hold":"0",
        #                 "holds":"0",
        #                 "lending_fee":"0"
        #             },
        #             "instrument_id":"BTC-USDT",
        #             "liquidation_price":"0",
        #             "product_id":"BTC-USDT",
        #             "risk_rate":""
        #         },
        #     ]
        #
        result = {'info': response}
        for i in range(0, len(response)):
            balance = response[i]
            marketId = self.safe_string(balance, 'instrument_id')
            market = self.safe_value(self.markets_by_id, marketId)
            symbol = None
            if market is None:
                baseId, quoteId = marketId.split('-')
                base = self.safe_currency_code(baseId)
                quote = self.safe_currency_code(quoteId)
                symbol = base + '/' + quote
            else:
                symbol = market['symbol']
            omittedBalance = self.omit(balance, [
                'instrument_id',
                'liquidation_price',
                'product_id',
                'risk_rate',
                'margin_ratio',
                'maint_margin_ratio',
                'tiers',
            ])
            keys = list(omittedBalance.keys())
            accounts = {}
            for k in range(0, len(keys)):
                key = keys[k]
                marketBalance = balance[key]
                if key.find(':') >= 0:
                    parts = key.split(':')
                    currencyId = parts[1]
                    code = self.safe_currency_code(currencyId)
                    account = self.account()
                    account['total'] = self.safe_number(marketBalance, 'balance')
                    account['used'] = self.safe_number(marketBalance, 'hold')
                    account['free'] = self.safe_number(marketBalance, 'available')
                    accounts[code] = account
                else:
                    raise NotSupported(self.id + ' margin balance response format has changed!')
            result[symbol] = self.parse_balance(accounts)
        return result

    def parse_futures_balance(self, response):
        #
        #     {
        #         "info":{
        #             "eos":{
        #                 "auto_margin":"0",
        #                 "contracts": [
        #                     {
        #                         "available_qty":"40.37069445",
        #                         "fixed_balance":"0",
        #                         "instrument_id":"EOS-USD-190329",
        #                         "margin_for_unfilled":"0",
        #                         "margin_frozen":"0",
        #                         "realized_pnl":"0",
        #                         "unrealized_pnl":"0"
        #                     },
        #                     {
        #                         "available_qty":"40.37069445",
        #                         "fixed_balance":"14.54895721",
        #                         "instrument_id":"EOS-USD-190628",
        #                         "margin_for_unfilled":"0",
        #                         "margin_frozen":"10.64042157",
        #                         "realized_pnl":"-3.90853564",
        #                         "unrealized_pnl":"-0.259"
        #                     },
        #                 ],
        #                 "equity":"50.75220665",
        #                 "margin_mode":"fixed",
        #                 "total_avail_balance":"40.37069445"
        #             },
        #         }
        #     }
        #
        # their root field name is "info", so our info will contain their info
        result = {'info': response}
        info = self.safe_value(response, 'info', {})
        ids = list(info.keys())
        for i in range(0, len(ids)):
            id = ids[i]
            code = self.safe_currency_code(id)
            balance = self.safe_value(info, id, {})
            account = self.account()
            totalAvailBalance = self.safe_number(balance, 'total_avail_balance')
            if self.safe_string(balance, 'margin_mode') == 'fixed':
                contracts = self.safe_value(balance, 'contracts', [])
                free = totalAvailBalance
                for i in range(0, len(contracts)):
                    contract = contracts[i]
                    fixedBalance = self.safe_number(contract, 'fixed_balance')
                    realizedPnl = self.safe_number(contract, 'realized_pnl')
                    marginFrozen = self.safe_number(contract, 'margin_frozen')
                    marginForUnfilled = self.safe_number(contract, 'margin_for_unfilled')
                    margin = self.sum(fixedBalance, realizedPnl) - marginFrozen - marginForUnfilled
                    free = self.sum(free, margin)
                account['free'] = free
            else:
                realizedPnl = self.safe_number(balance, 'realized_pnl')
                unrealizedPnl = self.safe_number(balance, 'unrealized_pnl')
                marginFrozen = self.safe_number(balance, 'margin_frozen')
                marginForUnfilled = self.safe_number(balance, 'margin_for_unfilled')
                account['free'] = self.sum(totalAvailBalance, realizedPnl,
                                           unrealizedPnl) - marginFrozen - marginForUnfilled
            # it may be incorrect to use total, free and used for swap accounts
            account['total'] = self.safe_number(balance, 'equity')
            result[code] = account
        return self.parse_balance(result)

    def parse_swap_balance(self, response):
        #
        #     {
        #         "info": [
        #             {
        #                 "equity":"3.0139",
        #                 "fixed_balance":"0.0000",
        #                 "instrument_id":"EOS-USD-SWAP",
        #                 "margin":"0.5523",
        #                 "margin_frozen":"0.0000",
        #                 "margin_mode":"crossed",
        #                 "margin_ratio":"1.0913",
        #                 "realized_pnl":"-0.0006",
        #                 "timestamp":"2019-03-25T03:46:10.336Z",
        #                 "total_avail_balance":"3.0000",
        #                 "unrealized_pnl":"0.0145"
        #             }
        #         ]
        #     }
        #
        # their root field name is "info", so our info will contain their info
        result = {'info': response}
        info = self.safe_value(response, 'info', [])
        for i in range(0, len(info)):
            balance = info[i]
            marketId = self.safe_string(balance, 'instrument_id')
            symbol = marketId
            if marketId in self.markets_by_id:
                symbol = self.markets_by_id[marketId]['symbol']
            account = self.account()
            # it may be incorrect to use total, free and used for swap accounts
            account['total'] = self.safe_number(balance, 'equity')
            account['free'] = self.safe_number(balance, 'total_avail_balance')
            result[symbol] = account
        return self.parse_balance(result)

    async def fetch_balance(self, params={}):
        method = 'accountGetBalance'
        response = await getattr(self, method)(params)

        # {
        #     "code": "0",
        #     "msg": "",
        #     "data": [{
        #         "uTime": "1614846244194",
        #         "totalEq": "91884.8502560037982063",
        #         "adjEq": "91884.8502560037982063",
        #         "isoEq": "0",
        #         "ordFroz": "0",
        #         "imr": "0",
        #         "mmr": "0",
        #         "mgnRatio": "100000",
        #         "details": [{
        #             "availBal": "",
        #             "availEq": "1",
        #             "ccy": "BTC",
        #             "cashBal": "1",
        #             "uTime": "1614846244194",
        #             "disEq": "50559.01",
        #             "eq": "1",
        #             "frozenBal": "0",
        #             "interest": "0",
        #             "isoEq": "0",
        #             "liab": "0",
        #             "mgnRatio": "",
        #             "ordFrozen": "0",
        #             "upl": "0",
        #             "uplLiab": "0",
        #             "upl": "0",
        #             "uplLiab": "0"
        #         },
        #             {
        #                 "availBal": "",
        #                 "availEq": "1",
        #                 "ccy": "BTC",
        #                 "cashBal": "1",
        #                 "uTime": "1614846244194",
        #                 "disEq": "50559.01",
        #                 "eq": "1",
        #                 "frozenBal": "0",
        #                 "interest": "0",
        #                 "isoEq": "0",
        #                 "liab": "0",
        #                 "mgnRatio": "",
        #                 "ordFrozen": "0",
        #                 "upl": "0",
        #                 "uplLiab": "0",
        #                 "upl": "0",
        #                 "uplLiab": "0"
        #             }
        #         ]
        #     }]
        # }
        # response = {
        #     "code": "0",
        #     "msg": "",
        #     "data": [{
        #         "uTime": "1614846244194",
        #         "totalEq": "91884.8502560037982063",
        #         "adjEq": "91884.8502560037982063",
        #         "isoEq": "0",
        #         "ordFroz": "0",
        #         "imr": "0",
        #         "mmr": "0",
        #         "mgnRatio": "100000",
        #         "details": [{
        #             "availBal": "1",
        #             "availEq": "1",
        #             "ccy": "BTC",
        #             "cashBal": "1",
        #             "uTime": "1614846244194",
        #             "disEq": "50559.01",
        #             "eq": "1",
        #             "frozenBal": "12",
        #             "interest": "0",
        #             "isoEq": "0",
        #             "liab": "0",
        #             "mgnRatio": "",
        #             "ordFrozen": "0",
        #             "upl": "0",
        #             "uplLiab": "0",
        #             "upl": "0",
        #             "uplLiab": "0"
        #         },
        #             {
        #                 "availBal": "2",
        #                 "availEq": "1",
        #                 "ccy": "USDT",
        #                 "cashBal": "1",
        #                 "uTime": "1614846244194",
        #                 "disEq": "50559.01",
        #                 "eq": "1",
        #                 "frozenBal": "12",
        #                 "interest": "0",
        #                 "isoEq": "0",
        #                 "liab": "0",
        #                 "mgnRatio": "",
        #                 "ordFrozen": "0",
        #                 "upl": "0",
        #                 "uplLiab": "0",
        #                 "upl": "0",
        #                 "uplLiab": "0"
        #             }
        #         ]
        #     }]
        # }
        return self.parse_balance(response['data'])

    def parse_balance(self, data):
        result = {}
        result['free'] = {}
        result['used'] = {}
        result['total'] = {}
        result['info'] = data
        for o in data[0]['details']:
            result['free'][o['ccy']] = o['availBal']
            result['used'][o['ccy']] = o['frozenBal']
            result['total'][o['ccy']] = self.sum(float(o['availBal']) + float(o['frozenBal']))
            result[o['ccy']] = {}
            result[o['ccy']]['free'] = o['availBal']
            result[o['ccy']]['used'] = o['frozenBal']
            result[o['ccy']]['total'] = result['total'][o['ccy']]

        return result

    def parse_balance_by_type(self, type, response):
        if (type == 'account') or (type == 'spot'):
            return self.parse_account_balance(response)
        elif type == 'margin':
            return self.parse_margin_balance(response)
        elif type == 'futures':
            return self.parse_futures_balance(response)
        elif type == 'swap':
            return self.parse_swap_balance(response)
        raise NotSupported(
            self.id + " fetchBalance does not support the '" + type + "' type(the type must be one of 'account', 'spot', 'margin', 'futures', 'swap')")

    def get_base_symbol(self, instId):
        return instId.replace('-', '/')

    def get_okex_symbol(self, symbol):
        return symbol.replace('/', '-')

    async def create_order(self, symbol, type, side, amount, price, clientOrderId, params):
        await self.load_markets()
        request = {}
        request['instId'] = self.get_okex_symbol(symbol)
        request['tdMode'] = 'cash'
        if clientOrderId:
            request['clOrdId'] = clientOrderId
        request['side'] = side
        request['ordType'] = type
        request['sz'] = amount
        if type == 'limit' and price:
            request['sz'] = self.amount_to_precision(symbol, amount)
            request['px'] = self.price_to_precision(symbol, price)
        method = 'tradePostOrder'
        response = await getattr(self, method)(self.extend(request))
        # {
        #     "code": "0",
        #     "data": [{
        #         "clOrdId": "",
        #         "ordId": "304368129476542464",
        #         "sCode": "0",
        #         "sMsg": "",
        #         "tag": ""
        #     }],
        #     "msg": ""
        # }
        data = response['data'][0]
        timestamp = self.milliseconds()
        return {
            'id': id,
            'client_order_id': clientOrderId if clientOrderId else None,
            'datetime': self.iso8601(timestamp),
            'timestamp': timestamp,
            'last_trade_timestamp': None,
            'status': 'open',
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'amount': amount,
            'spending': None,
            'filled': '0.0',
            'remaining': amount,
            'average': None,
            'cost': '0.0',
            'trades': None,
            'fee': {
                'currency': symbol,
                'cost': '0.0'
            },
            'info': data
        }

    async def fetch_order(self, id, symbol=None, params={}):
        request = {}
        if id:
            request['ordId'] = id
        if symbol:
            request['instId'] = self.get_okex_symbol(symbol)
        method = 'tradeGetOrder'
        response = await getattr(self, method)(self.extend(request, params))
        # {
        #     "code": "0",
        #     "data": [{
        #         "accFillSz": "49.017",
        #         "avgPx": "1.5017598665769018",
        #         "cTime": "1618809239445",
        #         "category": "normal",
        #         "ccy": "",
        #         "clOrdId": "",
        #         "fee": "-0.07361176338",
        #         "feeCcy": "USDT",
        #         "fillPx": "1.50171",
        #         "fillSz": "1.713",
        #         "fillTime": "1618809239449",
        #         "instId": "XRP-USDT",
        #         "instType": "SPOT",
        #         "lever": "",
        #         "ordId": "304243233555628032",
        #         "ordType": "market",
        #         "pnl": "0",
        #         "posSide": "net",
        #         "px": "",
        #         "rebate": "0",
        #         "rebateCcy": "XRP",
        #         "side": "sell",
        #         "slOrdPx": "",
        #         "slTriggerPx": "",
        #         "state": "filled",
        #         "sz": "49.017",
        #         "tag": "",
        #         "tdMode": "cash",
        #         "tpOrdPx": "",
        #         "tpTriggerPx": "",
        #         "tradeId": "30955492",
        #         "uTime": "1618809239452"
        #     }],
        #     "msg": ""
        # }
        return self.parse_order(response['data'][0])

    async def cancel_order(self, id=None, symbol=None, params={}):
        method = 'tradePostCancelOrder'
        response = await getattr(self, method)(self.extend(params))
        return response

    def parse_order_status(self, status):
        statuses = {
            '-2': 'failed',
            '-1': 'canceled',
            '0': 'open',
            '1': 'open',
            '2': 'closed',
            '3': 'open',
            '4': 'canceled',
        }
        return self.safe_string(statuses, status, status)

    def parse_order_side(self, side):
        sides = {
            '1': 'buy',  # open long
            '2': 'sell',  # open short
            '3': 'sell',  # close long
            '4': 'buy',  # close short
        }
        return self.safe_string(sides, side, side)

    def parse_order(self, data):
        id = self.safe_string(data, 'ordId')
        client_order_id = data['clOrdId'] if data['clOrdId'] else None
        cTime = int(data['cTime']) if data['cTime'] else None
        datetime = self.iso8601(cTime)
        timestamp = cTime
        last_trade_timestamp = data['fillTime'] if data['fillTime'] else None
        if data['state'] in ['live', 'partially_filled']:
            status = 'open'
        elif data['state'] == 'filled':
            status = 'closed'
        else:
            status = 'canceled'
        symbol = self.get_base_symbol(data['instId'])
        type = self.safe_string(data, 'ordType')
        side = self.safe_string(data, 'side')
        price = self.safe_string(data, 'px')
        amount = self.safe_string(data, 'sz')
        filled = self.safe_string(data, 'accFillSz')
        remaining = float(amount) - float(filled)
        average = self.safe_string(data, 'avgPx')
        if filled and price:
            cost = float(filled) * float(price)
        else:
            cost = None
        trades = {}
        feeCost = float(data['fee'])
        if feeCost < 0:
            feeCost = -feeCost
        else:
            feeCost = None
        fee = {
            'currency': symbol,
            'cost': feeCost
        }
        return {
            'id': id,
            'client_order_id': client_order_id,
            'datetime': datetime,
            'timestamp': timestamp,
            'last_trade_timestamp': last_trade_timestamp,
            'status': status,
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'amount': amount,
            'spending': None,
            'filled': filled,
            'remaining': remaining,
            'average': average,
            'cost': cost,
            'trades': trades,
            'fee': fee,
            'info': data
        }

    async def fetch_orders_by_state(self, state, symbol=None, since=None, limit=None, params={}):
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrdersByState() requires a symbol argument')
        await self.load_markets()
        market = self.market(symbol)
        type = None
        if market['futures'] or market['swap']:
            type = market['type']
        else:
            defaultType = self.safe_string_2(self.options, 'fetchOrder', 'defaultType', market['type'])
            type = self.safe_string(params, 'type', defaultType)
        if type is None:
            raise ArgumentsRequired(
                self.id + " fetchOrdersByState() requires a type parameter(one of 'spot', 'margin', 'futures', 'swap').")
        request = {
            'instrument_id': market['id'],
            # '-2': failed,
            # '-1': cancelled,
            #  '0': open ,
            #  '1': partially filled,
            #  '2': fully filled,
            #  '3': submitting,
            #  '4': cancelling,
            #  '6': incomplete（open+partially filled),
            #  '7': complete（cancelled+fully filled),
            'state': state,
        }
        method = type + 'GetOrders'
        if market['futures'] or market['swap']:
            method += 'InstrumentId'
        query = self.omit(params, 'type')
        response = await getattr(self, method)(self.extend(request, query))
        #
        # spot, margin
        #
        #     [
        #         # in fact, self documented API response does not correspond
        #         # to their actual API response for spot markets
        #         # OKEX v3 API returns a plain array of orders(see below)
        #         [
        #             {
        #                 "client_oid":"oktspot76",
        #                 "created_at":"2019-03-18T07:26:49.000Z",
        #                 "filled_notional":"3.9734",
        #                 "filled_size":"0.001",
        #                 "funds":"",
        #                 "instrument_id":"BTC-USDT",
        #                 "notional":"",
        #                 "order_id":"2500723297813504",
        #                 "order_type":"0",
        #                 "price":"4013",
        #                 "product_id":"BTC-USDT",
        #                 "side":"buy",
        #                 "size":"0.001",
        #                 "status":"filled",
        #                 "state": "2",
        #                 "timestamp":"2019-03-18T07:26:49.000Z",
        #                 "type":"limit"
        #             },
        #         ],
        #         {
        #             "before":"2500723297813504",
        #             "after":"2500650881647616"
        #         }
        #     ]
        #
        # futures, swap
        #
        #     {
        #         "result":true,  # missing in swap orders
        #         "order_info": [
        #             {
        #                 "instrument_id":"EOS-USD-190628",
        #                 "size":"10",
        #                 "timestamp":"2019-03-20T10:04:55.000Z",
        #                 "filled_qty":"10",
        #                 "fee":"-0.00841043",
        #                 "order_id":"2512669605501952",
        #                 "price":"3.668",
        #                 "price_avg":"3.567",
        #                 "status":"2",
        #                 "state": "2",
        #                 "type":"4",
        #                 "contract_val":"10",
        #                 "leverage":"10",  # missing in swap orders
        #                 "client_oid":"",
        #                 "pnl":"1.09510794",  # missing in swap orders
        #                 "order_type":"0"
        #             },
        #         ]
        #     }
        #
        orders = None
        if market['swap'] or market['futures']:
            orders = self.safe_value(response, 'order_info', [])
        else:
            orders = response
            responseLength = len(response)
            if responseLength < 1:
                return []
            # in fact, self documented API response does not correspond
            # to their actual API response for spot markets
            # OKEX v3 API returns a plain array of orders
            if responseLength > 1:
                before = self.safe_value(response[1], 'before')
                if before is not None:
                    orders = response[0]
        return self.parse_orders(orders, market, since, limit)

    def parse_deposit_address(self, depositAddress, currency=None):
        #
        #     {
        #         address: '0x696abb81974a8793352cbd33aadcf78eda3cfdfa',
        #         currency: 'eth'
        #         tag: 'abcde12345',  # will be missing if the token does not require a deposit tag
        #         payment_id: 'abcde12345',  # will not be returned if the token does not require a payment_id
        #         # can_deposit: 1,  # 0 or 1, documented but missing
        #         # can_withdraw: 1,  # 0 or 1, documented but missing
        #     }
        #
        address = self.safe_string(depositAddress, 'address')
        tag = self.safe_string_2(depositAddress, 'tag', 'payment_id')
        tag = self.safe_string(depositAddress, 'memo', tag)
        currencyId = self.safe_string(depositAddress, 'currency')
        code = self.safe_currency_code(currencyId)
        self.check_address(address)
        return {
            'currency': code,
            'address': address,
            'tag': tag,
            'info': depositAddress,
        }

    async def fetch_deposit_address(self, code, params={}):
        await self.load_markets()
        parts = code.split('-')
        currency = self.currency(parts[0])
        request = {
            'currency': currency['id'],
        }
        response = await self.accountGetDepositAddress(self.extend(request, params))
        #
        #     [
        #         {
        #             address: '0x696abb81974a8793352cbd33aadcf78eda3cfdfa',
        #             currency: 'eth'
        #         }
        #     ]
        #
        addressesByCode = self.parse_deposit_addresses(response)
        address = self.safe_value(addressesByCode, code)
        if address is None:
            raise InvalidAddress(
                self.id + ' fetchDepositAddress cannot return nonexistent addresses, you should create withdrawal addresses with the exchange website first')
        return address

    async def withdraw(self, code, amount, address, tag=None, params={}):
        self.check_address(address)
        await self.load_markets()
        currency = self.currency(code)
        if tag:
            address = address + ':' + tag
        fee = self.safe_string(params, 'fee')
        if fee is None:
            raise ArgumentsRequired(
                self.id + " withdraw() requires a `fee` string parameter, network transaction fee must be ≥ 0. Withdrawals to OKCoin or OKEx are fee-free, please set '0'. Withdrawing to external digital asset address requires network transaction fee.")
        request = {
            'currency': currency['id'],
            'to_address': address,
            'destination': '4',  # 2 = OKCoin International, 3 = OKEx 4 = others
            'amount': self.number_to_string(amount),
            'fee': fee,
            # String. Network transaction fee ≥ 0. Withdrawals to OKCoin or OKEx are fee-free, please set as 0. Withdrawal to external digital asset address requires network transaction fee.
        }
        if 'password' in params:
            request['trade_pwd'] = params['password']
        elif 'trade_pwd' in params:
            request['trade_pwd'] = params['trade_pwd']
        elif self.password:
            request['trade_pwd'] = self.password
        query = self.omit(params, ['fee', 'password', 'trade_pwd'])
        if not ('trade_pwd' in request):
            raise ExchangeError(
                self.id + ' withdraw() requires self.password set on the exchange instance or a password / trade_pwd parameter')
        response = await self.accountPostWithdrawal(self.extend(request, query))
        #
        #     {
        #         "amount":"0.1",
        #         "withdrawal_id":"67485",
        #         "currency":"btc",
        #         "result":true
        #     }
        #
        return {
            'info': response,
            'id': self.safe_string(response, 'withdrawal_id'),
        }

    async def fetch_deposits(self, code=None, since=None, limit=None, params={}):
        await self.load_markets()
        request = {}
        method = 'accountGetDepositHistory'
        currency = None
        if code is not None:
            currency = self.currency(code)
            request['currency'] = currency['id']
            method += 'Currency'
        response = await getattr(self, method)(self.extend(request, params))
        return self.parse_transactions(response, currency, since, limit, params)

    async def fetch_withdrawals(self, code=None, since=None, limit=None, params={}):
        await self.load_markets()
        request = {}
        method = 'accountGetWithdrawalHistory'
        currency = None
        if code is not None:
            currency = self.currency(code)
            request['currency'] = currency['id']
            method += 'Currency'
        response = await getattr(self, method)(self.extend(request, params))
        return self.parse_transactions(response, currency, since, limit, params)

    def parse_transaction_status(self, status):
        #
        # deposit statuses
        #
        #     {
        #         '0': 'waiting for confirmation',
        #         '1': 'confirmation account',
        #         '2': 'recharge success'
        #     }
        #
        # withdrawal statues
        #
        #     {
        #        '-3': 'pending cancel',
        #        '-2': 'cancelled',
        #        '-1': 'failed',
        #         '0': 'pending',
        #         '1': 'sending',
        #         '2': 'sent',
        #         '3': 'email confirmation',
        #         '4': 'manual confirmation',
        #         '5': 'awaiting identity confirmation'
        #     }
        #
        statuses = {
            '-3': 'pending',
            '-2': 'canceled',
            '-1': 'failed',
            '0': 'pending',
            '1': 'pending',
            '2': 'ok',
            '3': 'pending',
            '4': 'pending',
            '5': 'pending',
        }
        return self.safe_string(statuses, status, status)

    def parse_transaction(self, transaction, currency=None):
        #
        # withdraw
        #
        #     {
        #         "amount":"0.1",
        #         "withdrawal_id":"67485",
        #         "currency":"btc",
        #         "result":true
        #     }
        #
        # fetchWithdrawals
        #
        #     {
        #         amount: "4.72100000",
        #         withdrawal_id: "1729116",
        #         fee: "0.01000000eth",
        #         txid: "0xf653125bbf090bcfe4b5e8e7b8f586a9d87aa7de94598702758c0802b…",
        #         currency: "ETH",
        #         from: "7147338839",
        #         to: "0x26a3CB49578F07000575405a57888681249c35Fd",
        #         timestamp: "2018-08-17T07:03:42.000Z",
        #         status: "2"
        #     }
        #
        # fetchDeposits
        #
        #     {
        #         "amount": "4.19511659",
        #         "txid": "14c9a8c925647cdb7e5b2937ea9aefe2b29b2c273150ad3f44b3b8a4635ed437",
        #         "currency": "XMR",
        #         "from": "",
        #         "to": "48PjH3ksv1fiXniKvKvyH5UtFs5WhfS2Vf7U3TwzdRJtCc7HJWvCQe56dRahyhQyTAViXZ8Nzk4gQg6o4BJBMUoxNy8y8g7",
        #         "tag": "1234567",
        #         "deposit_id": 11571659, <-- we can use self
        #         "timestamp": "2019-10-01T14:54:19.000Z",
        #         "status": "2"
        #     }
        #
        type = None
        id = None
        address = None
        withdrawalId = self.safe_string(transaction, 'withdrawal_id')
        addressFrom = self.safe_string(transaction, 'from')
        addressTo = self.safe_string(transaction, 'to')
        tagTo = self.safe_string(transaction, 'tag')
        if withdrawalId is not None:
            type = 'withdrawal'
            id = withdrawalId
            address = addressTo
        else:
            # the payment_id will appear on new deposits but appears to be removed from the response after 2 months
            id = self.safe_string_2(transaction, 'payment_id', 'deposit_id')
            type = 'deposit'
            address = addressTo
        currencyId = self.safe_string(transaction, 'currency')
        code = self.safe_currency_code(currencyId)
        amount = self.safe_number(transaction, 'amount')
        status = self.parse_transaction_status(self.safe_string(transaction, 'status'))
        txid = self.safe_string(transaction, 'txid')
        timestamp = self.parse8601(self.safe_string(transaction, 'timestamp'))
        feeCost = None
        if type == 'deposit':
            feeCost = 0
        else:
            if currencyId is not None:
                feeWithCurrencyId = self.safe_string(transaction, 'fee')
                if feeWithCurrencyId is not None:
                    # https://github.com/ccxt/ccxt/pull/5748
                    lowercaseCurrencyId = currencyId.lower()
                    feeWithoutCurrencyId = feeWithCurrencyId.replace(lowercaseCurrencyId, '')
                    feeCost = float(feeWithoutCurrencyId)
        # todo parse tags
        return {
            'info': transaction,
            'id': id,
            'currency': code,
            'amount': amount,
            'addressFrom': addressFrom,
            'addressTo': addressTo,
            'address': address,
            'tagFrom': None,
            'tagTo': tagTo,
            'tag': tagTo,
            'status': status,
            'type': type,
            'updated': None,
            'txid': txid,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'fee': {
                'currency': code,
                'cost': feeCost,
            },
        }

    def parse_my_trade(self, pair, market=None):
        # check that trading symbols match in both entries
        userTrade = self.safe_value(pair, 1)
        otherTrade = self.safe_value(pair, 0)
        firstMarketId = self.safe_string(otherTrade, 'instrument_id')
        secondMarketId = self.safe_string(userTrade, 'instrument_id')
        if firstMarketId != secondMarketId:
            raise NotSupported(
                self.id + ' parseMyTrade() received unrecognized response format, differing instrument_ids in one fill, the exchange API might have changed, paste your verbose output: https://github.com/ccxt/ccxt/wiki/FAQ#what-is-required-to-get-help')
        marketId = firstMarketId
        market = self.safe_market(marketId, market)
        symbol = market['symbol']
        quoteId = market['quoteId']
        side = None
        amount = None
        cost = None
        receivedCurrencyId = self.safe_string(userTrade, 'currency')
        feeCurrencyId = None
        if receivedCurrencyId == quoteId:
            side = self.safe_string(otherTrade, 'side')
            amount = self.safe_number(otherTrade, 'size')
            cost = self.safe_number(userTrade, 'size')
            feeCurrencyId = self.safe_string(otherTrade, 'currency')
        else:
            side = self.safe_string(userTrade, 'side')
            amount = self.safe_number(userTrade, 'size')
            cost = self.safe_number(otherTrade, 'size')
            feeCurrencyId = self.safe_string(userTrade, 'currency')
        id = self.safe_string(userTrade, 'trade_id')
        price = self.safe_number(userTrade, 'price')
        feeCostFirst = self.safe_number(otherTrade, 'fee')
        feeCostSecond = self.safe_number(userTrade, 'fee')
        feeCurrencyCodeFirst = self.safe_currency_code(self.safe_string(otherTrade, 'currency'))
        feeCurrencyCodeSecond = self.safe_currency_code(self.safe_string(userTrade, 'currency'))
        fee = None
        fees = None
        # fee is either a positive number(invitation rebate)
        # or a negative number(transaction fee deduction)
        # therefore we need to invert the fee
        # more about it https://github.com/ccxt/ccxt/issues/5909
        if (feeCostFirst is not None) and (feeCostFirst != 0):
            if (feeCostSecond is not None) and (feeCostSecond != 0):
                fees = [
                    {
                        'cost': -feeCostFirst,
                        'currency': feeCurrencyCodeFirst,
                    },
                    {
                        'cost': -feeCostSecond,
                        'currency': feeCurrencyCodeSecond,
                    },
                ]
            else:
                fee = {
                    'cost': -feeCostFirst,
                    'currency': feeCurrencyCodeFirst,
                }
        elif (feeCostSecond is not None) and (feeCostSecond != 0):
            fee = {
                'cost': -feeCostSecond,
                'currency': feeCurrencyCodeSecond,
            }
        else:
            fee = {
                'cost': 0,
                'currency': self.safe_currency_code(feeCurrencyId),
            }
        #
        # simplified structures to show the underlying semantics
        #
        #     # market/limit sell
        #
        #     {
        #         "currency":"USDT",
        #         "fee":"-0.04647925",  # ←--- fee in received quote currency
        #         "price":"129.13",  # ←------ price
        #         "size":"30.98616393",  # ←-- cost
        #     },
        #     {
        #         "currency":"ETH",
        #         "fee":"0",
        #         "price":"129.13",
        #         "size":"0.23996099",  # ←--- amount
        #     },
        #
        #     # market/limit buy
        #
        #     {
        #         "currency":"ETH",
        #         "fee":"-0.00036049",  # ←--- fee in received base currency
        #         "price":"129.16",  # ←------ price
        #         "size":"0.240322",  # ←----- amount
        #     },
        #     {
        #         "currency":"USDT",
        #         "fee":"0",
        #         "price":"129.16",
        #         "size":"31.03998952",  # ←-- cost
        #     }
        #
        timestamp = self.parse8601(self.safe_string_2(userTrade, 'timestamp', 'created_at'))
        takerOrMaker = self.safe_string_2(userTrade, 'exec_type', 'liquidity')
        if takerOrMaker == 'M':
            takerOrMaker = 'maker'
        elif takerOrMaker == 'T':
            takerOrMaker = 'taker'
        orderId = self.safe_string(userTrade, 'order_id')
        result = {
            'info': pair,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'id': id,
            'order': orderId,
            'type': None,
            'takerOrMaker': takerOrMaker,
            'side': side,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': fee,
        }
        if fees is not None:
            result['fees'] = fees
        return result

    def parse_my_trades(self, trades):
        result = []
        for o in trades:
            d = {}
            d['info'] = o
            d['id'] = o['tradeId']
            d['timestamp'] = o['ts']
            d['datetime'] = self.iso8601(o['ts'])
            d['symbol'] = self.get_base_symbol(o['instId'])
            d['order'] = o['ordId']
            d['type'] = None
            d['side'] = o['side']
            d['takerOrMaker'] = 'taker' if o['execType'] == 'T' else 'maker'
            d['price'] = o['fillPx']
            d['amount'] = o['fillSz']
            d['cost'] = self.sum(float(d['price']) * float(d['amount']))
            cost = float(o['fee'])
            if cost < 0:
                fee = {
                    'currency': o['feeCcy'],
                    'cost': str(-cost),
                }
                d['fee'] = fee
            result.append(d)
        return result

    async def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        method = 'tradeGetFills'
        response = await getattr(self, method)(self.extend(params))
        # response = {
        #     "code": "0",
        #     "msg": "",
        #     "data": [
        #         {
        #             "instType": "FUTURES",
        #             "instId": "BTC-USD-200329",
        #             "tradeId": "123",
        #             "ordId": "123445",
        #             "billId": "1111",
        #             "tag": "",
        #             "fillPx": "999",
        #             "fillSz": "3",
        #             "side": "buy",
        #             "posSide": "long",
        #             "execType": "M",
        #             "feeCcy": "",
        #             "fee": "",
        #             "ts": "1597026383085"
        #         },
        #         {
        #             "instType": "FUTURES",
        #             "instId": "BTC-USD-200329",
        #             "tradeId": "123",
        #             "ordId": "123445",
        #             "billId": "1111",
        #             "tag": "",
        #             "fillPx": "999",
        #             "fillSz": "3",
        #             "side": "buy",
        #             "posSide": "long",
        #             "execType": "M",
        #             "feeCcy": "",
        #             "fee": "",
        #             "ts": "1597026383085"
        #         }
        #     ]
        # }
        return self.parse_my_trades(response['data'])

    async def fetch_order_trades(self, id, symbol=None, since=None, limit=None, params={}):
        request = {
            # 'instrument_id': market['id'],
            'order_id': id,
            # 'after': '1',  # return the page after the specified page number
            # 'before': '1',  # return the page before the specified page number
            # 'limit': limit,  # optional, number of results per request, default = maximum = 100
        }
        return await self.fetch_my_trades(symbol, since, limit, self.extend(request, params))

    async def fetch_position(self, symbol, params={}):
        await self.load_markets()
        market = self.market(symbol)
        method = None
        request = {
            'instrument_id': market['id'],
            # 'order_id': id,  # string
            # 'after': '1',  # pagination of data to return records earlier than the requested ledger_id
            # 'before': '1',  # P=pagination of data to return records newer than the requested ledger_id
            # 'limit': limit,  # optional, number of results per request, default = maximum = 100
        }
        type = market['type']
        if (type == 'futures') or (type == 'swap'):
            method = type + 'GetInstrumentIdPosition'
        elif type == 'option':
            underlying = self.safe_string(params, 'underlying')
            if underlying is None:
                raise ArgumentsRequired(
                    self.id + ' fetchPosition() requires an underlying parameter for ' + type + ' market ' + symbol)
            method = type + 'GetUnderlyingPosition'
        else:
            raise NotSupported(
                self.id + ' fetchPosition() does not support ' + type + ' market ' + symbol + ', supported market types are futures, swap or option')
        response = await getattr(self, method)(self.extend(request, params))
        #
        # futures
        #
        #     crossed margin mode
        #
        #     {
        #         "result": True,
        #         "holding": [
        #             {
        #                 "long_qty": "2",
        #                 "long_avail_qty": "2",
        #                 "long_avg_cost": "8260",
        #                 "long_settlement_price": "8260",
        #                 "realised_pnl": "0.00020928",
        #                 "short_qty": "2",
        #                 "short_avail_qty": "2",
        #                 "short_avg_cost": "8259.99",
        #                 "short_settlement_price": "8259.99",
        #                 "liquidation_price": "113.81",
        #                 "instrument_id": "BTC-USD-191227",
        #                 "leverage": "10",
        #                 "created_at": "2019-09-25T07:58:42.129Z",
        #                 "updated_at": "2019-10-08T14:02:51.029Z",
        #                 "margin_mode": "crossed",
        #                 "short_margin": "0.00242197",
        #                 "short_pnl": "6.63E-6",
        #                 "short_pnl_ratio": "0.002477997",
        #                 "short_unrealised_pnl": "6.63E-6",
        #                 "long_margin": "0.00242197",
        #                 "long_pnl": "-6.65E-6",
        #                 "long_pnl_ratio": "-0.002478",
        #                 "long_unrealised_pnl": "-6.65E-6",
        #                 "long_settled_pnl": "0",
        #                 "short_settled_pnl": "0",
        #                 "last": "8257.57"
        #             }
        #         ],
        #         "margin_mode": "crossed"
        #     }
        #
        #     fixed margin mode
        #
        #     {
        #         "result": True,
        #         "holding": [
        #             {
        #                 "long_qty": "4",
        #                 "long_avail_qty": "4",
        #                 "long_margin": "0.00323844",
        #                 "long_liqui_price": "7762.09",
        #                 "long_pnl_ratio": "0.06052306",
        #                 "long_avg_cost": "8234.43",
        #                 "long_settlement_price": "8234.43",
        #                 "realised_pnl": "-0.00000296",
        #                 "short_qty": "2",
        #                 "short_avail_qty": "2",
        #                 "short_margin": "0.00241105",
        #                 "short_liqui_price": "9166.74",
        #                 "short_pnl_ratio": "0.03318052",
        #                 "short_avg_cost": "8295.13",
        #                 "short_settlement_price": "8295.13",
        #                 "instrument_id": "BTC-USD-191227",
        #                 "long_leverage": "15",
        #                 "short_leverage": "10",
        #                 "created_at": "2019-09-25T07:58:42.129Z",
        #                 "updated_at": "2019-10-08T13:12:09.438Z",
        #                 "margin_mode": "fixed",
        #                 "short_margin_ratio": "0.10292507",
        #                 "short_maint_margin_ratio": "0.005",
        #                 "short_pnl": "7.853E-5",
        #                 "short_unrealised_pnl": "7.853E-5",
        #                 "long_margin_ratio": "0.07103743",
        #                 "long_maint_margin_ratio": "0.005",
        #                 "long_pnl": "1.9841E-4",
        #                 "long_unrealised_pnl": "1.9841E-4",
        #                 "long_settled_pnl": "0",
        #                 "short_settled_pnl": "0",
        #                 "last": "8266.99"
        #             }
        #         ],
        #         "margin_mode": "fixed"
        #     }
        #
        # swap
        #
        #     crossed margin mode
        #
        #     {
        #         "margin_mode": "crossed",
        #         "timestamp": "2019-09-27T03:49:02.018Z",
        #         "holding": [
        #             {
        #                 "avail_position": "3",
        #                 "avg_cost": "59.49",
        #                 "instrument_id": "LTC-USD-SWAP",
        #                 "last": "55.98",
        #                 "leverage": "10.00",
        #                 "liquidation_price": "4.37",
        #                 "maint_margin_ratio": "0.0100",
        #                 "margin": "0.0536",
        #                 "position": "3",
        #                 "realized_pnl": "0.0000",
        #                 "unrealized_pnl": "0",
        #                 "settled_pnl": "-0.0330",
        #                 "settlement_price": "55.84",
        #                 "side": "long",
        #                 "timestamp": "2019-09-27T03:49:02.018Z"
        #             },
        #         ]
        #     }
        #
        #     fixed margin mode
        #
        #     {
        #         "margin_mode": "fixed",
        #         "timestamp": "2019-09-27T03:47:37.230Z",
        #         "holding": [
        #             {
        #                 "avail_position": "20",
        #                 "avg_cost": "8025.0",
        #                 "instrument_id": "BTC-USD-SWAP",
        #                 "last": "8113.1",
        #                 "leverage": "15.00",
        #                 "liquidation_price": "7002.6",
        #                 "maint_margin_ratio": "0.0050",
        #                 "margin": "0.0454",
        #                 "position": "20",
        #                 "realized_pnl": "-0.0001",
        #                 "unrealized_pnl": "0",
        #                 "settled_pnl": "0.0076",
        #                 "settlement_price": "8279.2",
        #                 "side": "long",
        #                 "timestamp": "2019-09-27T03:47:37.230Z"
        #             }
        #         ]
        #     }
        #
        # option
        #
        #     {
        #         "holding":[
        #             {
        #                 "instrument_id":"BTC-USD-190927-12500-C",
        #                 "position":"20",
        #                 "avg_cost":"3.26",
        #                 "avail_position":"20",
        #                 "settlement_price":"0.017",
        #                 "total_pnl":"50",
        #                 "pnl_ratio":"0.3",
        #                 "realized_pnl":"40",
        #                 "unrealized_pnl":"10",
        #                 "pos_margin":"100",
        #                 "option_value":"70",
        #                 "created_at":"2019-08-30T03:09:20.315Z",
        #                 "updated_at":"2019-08-30T03:40:18.318Z"
        #             },
        #             {
        #                 "instrument_id":"BTC-USD-190927-12500-P",
        #                 "position":"20",
        #                 "avg_cost":"3.26",
        #                 "avail_position":"20",
        #                 "settlement_price":"0.019",
        #                 "total_pnl":"50",
        #                 "pnl_ratio":"0.3",
        #                 "realized_pnl":"40",
        #                 "unrealized_pnl":"10",
        #                 "pos_margin":"100",
        #                 "option_value":"70",
        #                 "created_at":"2019-08-30T03:09:20.315Z",
        #                 "updated_at":"2019-08-30T03:40:18.318Z"
        #             }
        #         ]
        #     }
        #
        # todo unify parsePosition/parsePositions
        return response

    async def fetch_positions(self, symbols=None, params={}):
        await self.load_markets()
        method = None
        defaultType = self.safe_string_2(self.options, 'fetchPositions', 'defaultType')
        type = self.safe_string(params, 'type', defaultType)
        if (type == 'futures') or (type == 'swap'):
            method = type + 'GetPosition'
        elif type == 'option':
            underlying = self.safe_string(params, 'underlying')
            if underlying is None:
                raise ArgumentsRequired(
                    self.id + ' fetchPositions() requires an underlying parameter for ' + type + ' markets')
            method = type + 'GetUnderlyingPosition'
        else:
            raise NotSupported(
                self.id + ' fetchPositions() does not support ' + type + ' markets, supported market types are futures, swap or option')
        params = self.omit(params, 'type')
        response = await getattr(self, method)(params)
        #
        # futures
        #
        #     ...
        #
        #
        # swap
        #
        #     ...
        #
        # option
        #
        #     {
        #         "holding":[
        #             {
        #                 "instrument_id":"BTC-USD-190927-12500-C",
        #                 "position":"20",
        #                 "avg_cost":"3.26",
        #                 "avail_position":"20",
        #                 "settlement_price":"0.017",
        #                 "total_pnl":"50",
        #                 "pnl_ratio":"0.3",
        #                 "realized_pnl":"40",
        #                 "unrealized_pnl":"10",
        #                 "pos_margin":"100",
        #                 "option_value":"70",
        #                 "created_at":"2019-08-30T03:09:20.315Z",
        #                 "updated_at":"2019-08-30T03:40:18.318Z"
        #             },
        #             {
        #                 "instrument_id":"BTC-USD-190927-12500-P",
        #                 "position":"20",
        #                 "avg_cost":"3.26",
        #                 "avail_position":"20",
        #                 "settlement_price":"0.019",
        #                 "total_pnl":"50",
        #                 "pnl_ratio":"0.3",
        #                 "realized_pnl":"40",
        #                 "unrealized_pnl":"10",
        #                 "pos_margin":"100",
        #                 "option_value":"70",
        #                 "created_at":"2019-08-30T03:09:20.315Z",
        #                 "updated_at":"2019-08-30T03:40:18.318Z"
        #             }
        #         ]
        #     }
        #
        # todo unify parsePosition/parsePositions
        return response

    async def fetch_ledger(self, code=None, since=None, limit=None, params={}):
        await self.load_markets()
        defaultType = self.safe_string_2(self.options, 'fetchLedger', 'defaultType')
        type = self.safe_string(params, 'type', defaultType)
        query = self.omit(params, 'type')
        suffix = '' if (type == 'account') else 'Accounts'
        argument = ''
        request = {
            # 'from': 'id',
            # 'to': 'id',
        }
        if limit is not None:
            request['limit'] = limit
        currency = None
        if type == 'spot':
            if code is None:
                raise ArgumentsRequired(
                    self.id + " fetchLedger() requires a currency code argument for '" + type + "' markets")
            argument = 'Currency'
            currency = self.currency(code)
            request['currency'] = currency['id']
        elif type == 'futures':
            if code is None:
                raise ArgumentsRequired(
                    self.id + " fetchLedger() requires an underlying symbol for '" + type + "' markets")
            argument = 'Underlying'
            market = self.market(code)  # we intentionally put a market inside here for the margin and swap ledgers
            marketInfo = self.safe_value(market, 'info', {})
            settlementCurrencyId = self.safe_string(marketInfo, 'settlement_currency')
            settlementCurrencyСode = self.safe_currency_code(settlementCurrencyId)
            currency = self.currency(settlementCurrencyСode)
            underlyingId = self.safe_string(marketInfo, 'underlying')
            request['underlying'] = underlyingId
        elif (type == 'margin') or (type == 'swap'):
            if code is None:
                raise ArgumentsRequired(
                    self.id + " fetchLedger() requires a code argument(a market symbol) for '" + type + "' markets")
            argument = 'InstrumentId'
            market = self.market(code)  # we intentionally put a market inside here for the margin and swap ledgers
            currency = self.currency(market['base'])
            request['instrument_id'] = market['id']
            #
            #     if type == 'margin':
            #         #
            #         #      3. Borrow
            #         #      4. Repayment
            #         #      5. Interest
            #         #      7. Buy
            #         #      8. Sell
            #         #      9. From capital account
            #         #     10. From C2C
            #         #     11. From Futures
            #         #     12. From Spot
            #         #     13. From ETT
            #         #     14. To capital account
            #         #     15. To C2C
            #         #     16. To Spot
            #         #     17. To Futures
            #         #     18. To ETT
            #         #     19. Mandatory Repayment
            #         #     20. From Piggybank
            #         #     21. To Piggybank
            #         #     22. From Perpetual
            #         #     23. To Perpetual
            #         #     24. Liquidation Fee
            #         #     54. Clawback
            #         #     59. Airdrop Return.
            #         #
            #         request['type'] = 'number'  # All types will be returned if self filed is left blank
            #     }
            #
        elif type == 'account':
            if code is not None:
                currency = self.currency(code)
                request['currency'] = currency['id']
            #
            #     #
            #     #      1. deposit
            #     #      2. withdrawal
            #     #     13. cancel withdrawal
            #     #     18. into futures account
            #     #     19. out of futures account
            #     #     20. into sub account
            #     #     21. out of sub account
            #     #     28. claim
            #     #     29. into ETT account
            #     #     30. out of ETT account
            #     #     31. into C2C account
            #     #     32. out of C2C account
            #     #     33. into margin account
            #     #     34. out of margin account
            #     #     37. into spot account
            #     #     38. out of spot account
            #     #
            #     request['type'] = 'number'
            #
        else:
            raise NotSupported(
                self.id + " fetchLedger does not support the '" + type + "' type(the type must be one of 'account', 'spot', 'margin', 'futures', 'swap')")
        method = type + 'Get' + suffix + argument + 'Ledger'
        response = await getattr(self, method)(self.extend(request, query))
        #
        # transfer     funds transfer in/out
        # trade        funds moved as a result of a trade, spot and margin accounts only
        # rebate       fee rebate as per fee schedule, spot and margin accounts only
        # match        open long/open short/close long/close short(futures) or a change in the amount because of trades(swap)
        # fee          fee, futures only
        # settlement   settlement/clawback/settle long/settle short
        # liquidation  force close long/force close short/deliver close long/deliver close short
        # funding      funding fee, swap only
        # margin       a change in the amount after adjusting margin, swap only
        #
        # account
        #
        #     [
        #         {
        #             "amount":0.00051843,
        #             "balance":0.00100941,
        #             "currency":"BTC",
        #             "fee":0,
        #             "ledger_id":8987285,
        #             "timestamp":"2018-10-12T11:01:14.000Z",
        #             "typename":"Get from activity"
        #         }
        #     ]
        #
        # spot
        #
        #     [
        #         {
        #             "timestamp":"2019-03-18T07:08:25.000Z",
        #             "ledger_id":"3995334780",
        #             "created_at":"2019-03-18T07:08:25.000Z",
        #             "currency":"BTC",
        #             "amount":"0.0009985",
        #             "balance":"0.0029955",
        #             "type":"trade",
        #             "details":{
        #                 "instrument_id":"BTC-USDT",
        #                 "order_id":"2500650881647616",
        #                 "product_id":"BTC-USDT"
        #             }
        #         }
        #     ]
        #
        # margin
        #
        #     [
        #         [
        #             {
        #                 "created_at":"2019-03-20T03:45:05.000Z",
        #                 "ledger_id":"78918186",
        #                 "timestamp":"2019-03-20T03:45:05.000Z",
        #                 "currency":"EOS",
        #                 "amount":"0",  # ?
        #                 "balance":"0.59957711",
        #                 "type":"transfer",
        #                 "details":{
        #                     "instrument_id":"EOS-USDT",
        #                     "order_id":"787057",
        #                     "product_id":"EOS-USDT"
        #                 }
        #             }
        #         ],
        #         {
        #             "before":"78965766",
        #             "after":"78918186"
        #         }
        #     ]
        #
        # futures
        #
        #     [
        #         {
        #             "ledger_id":"2508090544914461",
        #             "timestamp":"2019-03-19T14:40:24.000Z",
        #             "amount":"-0.00529521",
        #             "balance":"0",
        #             "currency":"EOS",
        #             "type":"fee",
        #             "details":{
        #                 "order_id":"2506982456445952",
        #                 "instrument_id":"EOS-USD-190628"
        #             }
        #         }
        #     ]
        #
        # swap
        #
        #     [
        #         {
        #             "amount":"0.004742",
        #             "fee":"-0.000551",
        #             "type":"match",
        #             "instrument_id":"EOS-USD-SWAP",
        #             "ledger_id":"197429674941902848",
        #             "timestamp":"2019-03-25T05:56:31.286Z"
        #         },
        #     ]
        #
        responseLength = len(response)
        if responseLength < 1:
            return []
        isArray = isinstance(response[0], list)
        isMargin = (type == 'margin')
        entries = response[0] if (isMargin and isArray) else response
        if type == 'swap':
            ledgerEntries = self.parse_ledger(entries)
            return self.filter_by_symbol_since_limit(ledgerEntries, code, since, limit)
        return self.parse_ledger(entries, currency, since, limit)

    def parse_ledger_entry_type(self, type):
        types = {
            'transfer': 'transfer',  # # funds transfer in/out
            'trade': 'trade',  # funds moved as a result of a trade, spot and margin accounts only
            'rebate': 'rebate',  # fee rebate as per fee schedule, spot and margin accounts only
            'match': 'trade',
            # open long/open short/close long/close short(futures) or a change in the amount because of trades(swap)
            'fee': 'fee',  # fee, futures only
            'settlement': 'trade',  # settlement/clawback/settle long/settle short
            'liquidation': 'trade',  # force close long/force close short/deliver close long/deliver close short
            'funding': 'fee',  # funding fee, swap only
            'margin': 'margin',  # a change in the amount after adjusting margin, swap only
        }
        return self.safe_string(types, type, type)

    def parse_ledger_entry(self, item, currency=None):
        #
        #
        # account
        #
        #     {
        #         "amount":0.00051843,
        #         "balance":0.00100941,
        #         "currency":"BTC",
        #         "fee":0,
        #         "ledger_id":8987285,
        #         "timestamp":"2018-10-12T11:01:14.000Z",
        #         "typename":"Get from activity"
        #     }
        #
        # spot
        #
        #     {
        #         "timestamp":"2019-03-18T07:08:25.000Z",
        #         "ledger_id":"3995334780",
        #         "created_at":"2019-03-18T07:08:25.000Z",
        #         "currency":"BTC",
        #         "amount":"0.0009985",
        #         "balance":"0.0029955",
        #         "type":"trade",
        #         "details":{
        #             "instrument_id":"BTC-USDT",
        #             "order_id":"2500650881647616",
        #             "product_id":"BTC-USDT"
        #         }
        #     }
        #
        # margin
        #
        #     {
        #         "created_at":"2019-03-20T03:45:05.000Z",
        #         "ledger_id":"78918186",
        #         "timestamp":"2019-03-20T03:45:05.000Z",
        #         "currency":"EOS",
        #         "amount":"0",  # ?
        #         "balance":"0.59957711",
        #         "type":"transfer",
        #         "details":{
        #             "instrument_id":"EOS-USDT",
        #             "order_id":"787057",
        #             "product_id":"EOS-USDT"
        #         }
        #     }
        #
        # futures
        #
        #     {
        #         "ledger_id":"2508090544914461",
        #         "timestamp":"2019-03-19T14:40:24.000Z",
        #         "amount":"-0.00529521",
        #         "balance":"0",
        #         "currency":"EOS",
        #         "type":"fee",
        #         "details":{
        #             "order_id":"2506982456445952",
        #             "instrument_id":"EOS-USD-190628"
        #         }
        #     }
        #
        # swap
        #
        #     {
        #         "amount":"0.004742",
        #         "fee":"-0.000551",
        #         "type":"match",
        #         "instrument_id":"EOS-USD-SWAP",
        #         "ledger_id":"197429674941902848",
        #         "timestamp":"2019-03-25T05:56:31.286Z"
        #     },
        #
        id = self.safe_string(item, 'ledger_id')
        account = None
        details = self.safe_value(item, 'details', {})
        referenceId = self.safe_string(details, 'order_id')
        referenceAccount = None
        type = self.parse_ledger_entry_type(self.safe_string(item, 'type'))
        code = self.safe_currency_code(self.safe_string(item, 'currency'), currency)
        amount = self.safe_number(item, 'amount')
        timestamp = self.parse8601(self.safe_string(item, 'timestamp'))
        fee = {
            'cost': self.safe_number(item, 'fee'),
            'currency': code,
        }
        before = None
        after = self.safe_number(item, 'balance')
        status = 'ok'
        marketId = self.safe_string(item, 'instrument_id')
        symbol = None
        if marketId in self.markets_by_id:
            market = self.markets_by_id[marketId]
            symbol = market['symbol']
        return {
            'info': item,
            'id': id,
            'account': account,
            'referenceId': referenceId,
            'referenceAccount': referenceAccount,
            'type': type,
            'currency': code,
            'symbol': symbol,
            'amount': amount,
            'before': before,  # balance before
            'after': after,  # balance after
            'status': status,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'fee': fee,
        }

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        isArray = isinstance(params, list)
        request = '/api/' + self.version + '/' + api + '/'
        request += path if isArray else self.implode_params(path, params)
        query = params if isArray else self.omit(params, self.extract_params(path))
        url = self.implode_params(self.urls['api']['rest'], {'hostname': self.hostname}) + request
        type = self.get_path_authentication_type(path)
        if type == 'public':
            if query:
                url += '?' + self.urlencode(query)
        elif type == 'private':
            self.check_required_credentials()
            timestamp = self.iso8601(self.milliseconds())
            headers = {
                'OK-ACCESS-KEY': self.apiKey,
                'OK-ACCESS-PASSPHRASE': self.password,
                'OK-ACCESS-TIMESTAMP': timestamp,
            }
            auth = timestamp + method + request
            if method == 'GET':
                if query:
                    urlencodedQuery = '?' + self.urlencode(query)
                    url += urlencodedQuery
                    auth += urlencodedQuery
            else:
                if isArray or query:
                    body = self.json(query)
                    auth += body
                headers['Content-Type'] = 'application/json'
            signature = self.hmac(self.encode(auth), self.encode(self.secret), hashlib.sha256, 'base64').decode()
            headers['OK-ACCESS-SIGN'] = signature
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def get_path_authentication_type(self, path):
        # https://github.com/ccxt/ccxt/issues/6651
        # a special case to handle the optionGetUnderlying interefering with
        # other endpoints containing self keyword
        if path == 'underlying':
            return 'public'
        auth = self.safe_value(self.options, 'auth', {})
        key = self.find_broadly_matched_key(auth, path)
        return self.safe_string(auth, key, 'private')

    def handle_errors(self, code, reason, url, method, headers, body, response, requestHeaders, requestBody):
        if not response:
            return  # fallback to default error handler
        feedback = self.id + ' ' + body
        if code == 503:
            # {"message":"name resolution failed"}
            raise ExchangeNotAvailable(feedback)
        errorCode = self.safe_string_2(response, 'code', 'error_code')
        if errorCode!='1':
            self.throw_exactly_matched_exception(self.exceptions['code'], errorCode, feedback)
            if response.get('data') and len(response['data']) > 0 and response['data'][0].get('sCode') and response['data'][0].get('sMsg'):
                sCode = response['data'][0]['sCode']
                sMsg = response['data'][0]['sMsg']
                if sCode:
                    self.throw_exactly_matched_exception(self.exceptions['sCode'], sCode, feedback)
                if sMsg:
                    self.throw_exactly_matched_exception(self.exceptions['sMsg'], sMsg, feedback)

    def safe_market(self, marketId, market=None, delimiter=None):
        if marketId is not None:
            if self.markets_by_id is not None and marketId in self.markets_by_id:
                market = self.markets_by_id[marketId]
            elif delimiter is not None:
                baseId, quoteId = marketId.split(delimiter)
                base = self.safe_currency_code(baseId)
                quote = self.safe_currency_code(quoteId)
                symbol = base + '/' + quote
                return {
                    'symbol': symbol,
                    'base': base,
                    'quote': quote,
                    'baseId': baseId,
                    'quoteId': quoteId,
                }
        if market is not None:
            return market
        return {
            'symbol': marketId,
            'base': None,
            'quote': None,
            'baseId': None,
            'quoteId': None,
        }

    number = float  # or str (a pointer to a class)

    def parse_number(self, value, default=None):
        if value is None:
            return default
        else:
            try:
                return self.number(value)
            except Exception:
                return default

    def safe_number(self, dictionary, key, default=None):
        value = self.safe_string(dictionary, key)
        return self.parse_number(value, default)

    def safe_number_2(self, dictionary, key1, key2, default=None):
        value = self.safe_string_2(dictionary, key1, key2)
        return self.parse_number(value, default)

    async def fetch_trading_fees(self, params={}):
        method = 'accountGetTradeFee'
        if params.get('instId'):
            symbol = params['instId']
        else:
            raise ArgumentsRequired(" FetchTradingFees() requires parameter symbol")
        params['instId'] = params['instId'].replace('/', '-')
        response = await getattr(self, method)(self.extend(params))
        return self.parse_trading_fees(response['data'], symbol)

    def parse_trading_fees(self, trading_fees, symbol):
        for o in trading_fees:
            o['symbol'] = symbol
        return trading_fees

    async def fetch_open_orders(self, symbol, since=None, limit=None, params=None):
        method = 'tradeGetOrdersPending'
        response = await getattr(self, method)(self.extend(params))
        # response = {
        #     "code": "0",
        #     "msg": "",
        #     "data": [
        #         {
        #             "accFillSz": "0",
        #             "avgPx": "",
        #             "cTime": "1618235248028",
        #             "category": "normal",
        #             "ccy": "",
        #             "clOrdId": "",
        #             "fee": "0",
        #             "feeCcy": "BTC",
        #             "fillPx": "",
        #             "fillSz": "0",
        #             "fillTime": "",
        #             "instId": "BTC-USDT",
        #             "instType": "SPOT",
        #             "lever": "5.6",
        #             "ordId": "301835739059335168",
        #             "ordType": "limit",
        #             "pnl": "0",
        #             "posSide": "net",
        #             "px": "59200",
        #             "rebate": "0",
        #             "rebateCcy": "USDT",
        #             "side": "buy",
        #             "slOrdPx": "",
        #             "slTriggerPx": "",
        #             "state": "live",
        #             "sz": "1",
        #             "tag": "",
        #             "tdMode": "cross",
        #             "tpOrdPx": "",
        #             "tpTriggerPx": "",
        #             "tradeId": "",
        #             "uTime": "1618235248028"
        #         }
        #     ]
        # }
        if response.get('data'):
            return self.perse_orders(response['data'])
        else:
            return []

    async def fetch_closed_orders(self, symbol, since=None, limit=None, params=None):
        method = 'tradeGetOrdersHistoryArchive'
        response = await getattr(self, method)(self.extend(params))
        # {
        #     "code": "0",
        #     "msg": "",
        #     "data": [
        #         {
        #             "instType": "FUTURES",
        #             "instId": "BTC-USD-200329",
        #             "ccy": "",
        #             "ordId": "123445",
        #             "clOrdId": "b1",
        #             "tag": "",
        #             "px": "999",
        #             "sz": "3",
        #             "ordType": "limit",
        #             "side": "buy",
        #             "posSide": "long",
        #             "tdMode": "isolated",
        #             "accFillSz": "0",
        #             "fillPx": "0",
        #             "tradeId": "0",
        #             "fillSz": "0",
        #             "fillTime": "0",
        #             "state": "live",
        #             "avgPx": "0",
        #             "lever": "20",
        #             "tpTriggerPx": "",
        #             "tpOrdPx": "",
        #             "slTriggerPx": "",
        #             "slOrdPx": "",
        #             "feeCcy": "",
        #             "fee": "",
        #             "rebateCcy": "",
        #             "rebate": "",
        #             "pnl": "",
        #             "category": "",
        #             "uTime": "1597026383085",
        #             "cTime": "1597026383085"
        #         }
        #     ]
        # }
        if response.get('data'):
            return self.perse_orders(response['data'])
        else:
            return []

    def perse_orders(self, data):
        result = []
        for o in data:
            result.append(self.parse_order(o))
        return result
